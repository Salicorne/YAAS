\documentclass[a4paper, 11pt]{report}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}

\title{YAAS Project : Report}
\author{Timoth√©e RABOEUF - 74764}
\date{28 oct. 2018} 
    
\begin{document} 
\maketitle
\tableofcontents
    
\chapter{Introduction}

    \section{Implemented requirements}

    The following list of requirements has been implemented : 
    \begin{itemize}
        \item UC1: create user
        \item UC2: edit user
        \item UC3: create auction
        \item UC4: edit auction description
        \item UC6: bid
        \item UC5: Browse \& Search
        \item UC7: ban auction
        \item UC8: resolve auction
        \item UC9: language switching
        \item UC10: concurrency
        \item UC11: currency exchange
        \item WS1: Browse \& Search API
        \item WS2: Bid api
        %\item OP2: soft deadlines for bidding
        %\item OP3: store language preference
        %\item OP1: send seller auction link
        \item TR1: data generation program
        %\item TR2

    \end{itemize}

    \section{Packages used}
    This YAAS application relies on the following packages :
    \begin{itemize}
        \item Django (2.1.1)
        \item django-crispy-forms (1.7.2)
        \item django-filter (2.0.0) 
        \item djangorestframework (3.8.2)
        \item Markdown (3.0.1)
        \item requests (2.20.0)
        
    \end{itemize}

\chapter{Development strategies}

    \section{Session management}

    \section{Confirmation form (UC3)}

    UC3 states that the user should be asked for a confirmation before creating a new auction. I implemented it using the rendering of a confirmation form, containing all auction informations in hidden field. The first auction creation form is validated server-side : if all informations are correct, the confirmation form is shown with these informations. Only when this confirmation form is submited the new auction is created and saved in database : thus if the user cancels the process or never submits the form the auction is not saved. This behaviour is described in the file \texttt{Auction/views.py}, in the functions \texttt{AuctionEditView::get}, \texttt{AuctionEditView::post} and \texttt{auctionConfirm}. 

    \section{Automatic bid resolution}

    For the bids resolution, the problematic is to allow resolution without any web request being made. We can't use classic Django views, and need to find another method. To begin I had a look at the Django module \texttt{django\_cron} but all it does is exposing a django command allowing to run jobs through \texttt{manage.py}, but still relies on an external tool (such as Unix crontab) to run this command. The module \texttt{django-extensions} has a jobs scheduling system, but it does not run jobs automatically either. I ended up manually launching a new thread, that will check all active (ie not banned and not resolved) auctions every minute and resolve them if needed. This thread is flagged as \texttt{daemonic} : \textit{the entire Python program exits when only daemon threads are left. }\footnote{https://docs.python.org/3/library/threading.html} This allows the program to run without worrying about this thread, and commands ran via \texttt{manage.py} to be non-blocking (as this thread will be launched during their execution). 

    This auctions resolution thread is launched in the Auction app initialization. This is achieved thanks to the \texttt{AuctionConfig} class, subclassing \texttt{AppConfig} in Auction/apps.py. This config class is declared in the \_\_init.py\_\_ file of the Auction module. Beware : when using \texttt{python manage.py runserver}, Django starts two processes : one for the development web server and another process to automatically reload the application on code change. The Auction app is loaded in both processes, causing the auctions resolution thread to be launched twice. To avoid this behaviour, the development server should be launched with \texttt{python manage.py runserver --noreload} and manually restarted on any code change. 

    \section{Concurrency management}

    This YAAS application relies on optimistic concurrency management : each auction has a \texttt{bid\_version} attribute, and this version is checked when bidding. If the version is not up-to-date, the bidding process will be aborted and the user will be asked to refresh the page so as to see the up-to-date version. An auction version will be outdated when the description is updated, or when a bid is made by another user. It is important to keep in mind that this optimistic concurency will not be 100\% efficient if the application runs on several threads : if two users make a bid at the exact same time, there could be a CPU jump between the processing of the two requests, between the version validation and the actual bidding. We would have to implement a database locking mecanism in that case, but this is not supported by Django for SQLite. 

    \section{REST API}

    The REST API is implemented using the \textit{Django REST Framework}. It follows main REST principles : it relies on HTTP verbs (GET, POST), and is \textit{stateless} : there is no state kept on the server, and each request is independant. The code is shared between the regular web app and the API : for a single action there is a function for the actual action, and two other englobing functions used to call this main function from the regular views and from the API. The naming convention is as follows :

    \begin{itemize}
        \item \texttt{get\_function} : The actual code logic
        \item \texttt{api\_function} : Used to call the function from the API
        \item \texttt{function} : Used to call the function from the web app.
    \end{itemize}

    \section{Functional tests}

    \section{Language switching management}

    \section{Data generation}

\end{document}